### 递归

##### 定义

方法定义中调用方法本身的现象



#### 递归中解决问题的方法

##### 分解法

把大问题不断拆分成小问题去解决

##### 合并法

再把小问题的结果返回给上一级，最终解决大问题。



#### 递归实现的思路

- 做递归要实现一个方法
- 出口条件
- 规律





---



### IO流

前提：异常、File

- IO流用来处理设备之间的数据传输

- Java对数据的操作是通过流的方式

- Java用于操作流的对象都在IO包中



#### 按流向分类

##### 1. 输入流 

读取数据



##### 2. 输出流 

写出数据



#### 按数据类型分类（默认）

##### 1.字节流

##### **InputStream**

此抽象类是表示字节输入流的所有类的超类

##### **OutputStream**

此抽象类是表示输出字节流的所有类的超类



##### 2. 字符流

为了方便操作文本数据

##### Reader

用于读取字符流的抽象类。

##### Writer

写入字符流的抽象类。



---

### 字节流



#### 创建字节输出流对象做了几件事

1.调用系统功能创建文件

2.创建子节输出流对象

3.将对象指向文件





#### 字节输出流操作步骤

1. 创建字节输出流对象

2. 调用write()方法

3. close()释放资源

- 让流对象变为垃圾，垃圾回收
- 通知系统去释放跟文件相关的资源



#### 字节输入流

一般一次读取1024个字节



#### 字节缓冲区流

**字节缓冲区流仅仅提供缓冲区，为高效而设计。**

但是，真正的读写操作，还得靠基本的流对象实现。



- 字节缓冲输出流

- - BufferedOutputStream

- 字节缓冲输入流

- - BufferedInputStream



---

### 字符流

#### 转换流

字节流操作中文数据不是特别方便

转换流的作用就是把字节流转换为字符流来使用



##### 转换流其实是一个字符流

##### 字符流 = 字节流 + 编码表



#### 编码表

由现实世界的字符和对应的数值组成的一张表

计算机只能识别二进制数据，早期由来是电信号。
为了方便应用计算机，让它可以识别各个国家的文字。
就将各个国家的文字用数字来表示，并一一对应，形成一张表。

ASCII：美国标准信息交换码。
用一个字节的7位可以表示。

ISO8859-1：拉丁码表。欧洲码表

用一个字节的8位表示。

GB2312：中国的中文编码表。

GBK：中国的中文编码表升级，融合了更多的中文文字符号。

GB18030：GBK的取代版本

BIG-5码 ：通行于台湾、香港地区的一个繁体字编码方案，俗称“大五码”。

Unicode：国际标准码，融合了多种文字。
所有文字都用两个字节来表示,Java语言使用的就是unicode

UTF-8：最多用三个字节来表示一个字符。

UTF-8不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容：
它将Unicode编码为00000000-0000007F的字符，用单个字节来表示它将Unicode编码为00000080-000007FF的字符用两个字节表示 它将Unicode编码为00000800-0000FFFF的字符用3字节表示 



#### IO流中的编码问题

##### 编码

把看得懂的变成看不懂的



##### 解码

把看不懂的变成看的懂得



---

#### OutputStreamWriter 字符输出流

OutputStreamWriter 是**字符流通向字节流的桥梁**：

可使用指定的 [`charset`](https://tool.oschina.net/uploads/apidocs/jdk-zh/java/nio/charset/Charset.html) 将要写入流中的字符编码成字节。

```java
public OutputStreamWriter(OutputStream out) // 根据默认编码把字节流数据转换为字符流

public OutputStreamWriter(OutputStream out,String charsetName) //根据指定编码把字节流转换为字符流
```



#### InputStreamReader 字符输入流

```java
public InputStreamReader(InputStream in)

public InputStreamReader(InputStream in,String charsetName)
```



#### close和flush的区别

close()关闭流对象，但是先刷新一次缓冲区。关闭之后，流对象不可以继续再使用了。

flush()仅仅刷新缓冲区，刷新之后，流对象还可以继续使用。



#### 转换流的简化写法

- FileWriter
- FileReader



---



### 字符缓冲流

#### BufferedWriter

将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。

基本用法



##### 特殊功能

**根据操作系统来决定换行符**

```java
void newLine()
```



#### BufferedReader

基本用法



##### 特殊功能

**一次读取一行数据**

```java
String readLine()
```





---

#### 传输数据的步骤

1. 封装数据源

2. 封装目的地

3. 读写数据

4. 释放资源





---

### 数据操作流

##### 可以操作基本类型的数据



- DataInputStream

然后，应用程序可以使用数据输入流将数据读入。



- DataOutputStream

数据输出流允许应用程序以适当方式将基本 Java 数据类型写入输出流中。



---

### 内存操作流

##### 内存操作流一般用于处理临时信息

程序结束，数据就从内存消失。



- 操作字节数组

ByteArrayInputStream

ByteArrayOutputStream

- 操作字符数组

CharArrayReader

CharArrayWrite

- 操作字符串

StringReader

StringWriter



---

### 打印流



- 字节打印流

PrintStream



- 字符打印流

PrintWriter



#### 打印流特点

1. 只能操作目的地，不能操作数据。

2. 可以操作任意类型的数据。

3. 如果启动了自动刷新，能够自动刷新。

4. 可以操作文件的流



---

### 标准输入输出流



---

### 随机访问流

可以按照文件指针的位置写数据和读数据。

---

### 合并流

把多个输入流的数据写到一个输出流中。

----

### 序列化流

可以把对象按照流一样写入文本文件或者在网络中传输

一般的格式是与平台无关的二进制流，可以将这种二进制流持久保存在磁盘上，

也可以通过网络将这种二进制流传输到另一个网络结点。



##### 对象需要使用序列化接口实现序列化

##### 标记接口

序列化接口没有任何方法，类似于这种没有方法的接口被称为标记接口。



#### 反序列化流

把流数据还原为对象



#### ObjectOutputStream

将java对象写入流中，可以使用ObjectInputStream读取对象。

通过在流中使用文件可以实现对象的持久存储。

如果流是网络套接字流，则可以在另一台主机上或另一个进程中读取对象



##### 把数据写到文件后，在去修改类会产生一个问题。

​		如何解决该问题呢?

​			在类文件中，给出一个固定的序列化id值。

​			而且，这样也可以解决黄色警告线问题



#### 使用transient关键字声明不需要序列化的成员变量



面试题：

​		什么时候序列化?

​		如何实现序列化?

​		什么是反序列化?

---

### Properties

是一个集合类，Hashtable的子类

---

### NIO

JDK4出现的NIO，对以前的IO操作进行了优化，提供了效率。但是大部分我们看到的还是以前的IO

---

