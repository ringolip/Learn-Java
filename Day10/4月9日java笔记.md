### 接口

接口就是一种**公共的规范标准**

 

### Java的接口

#### 1.接口是方法的集合

接口的内部主要就是封装了方法

- 抽象方法（JDK7）
- 默认方法（JDK8）
- 静态方法（JDK8）
- 私有方法（JDK9）

#### 2.接口是一种引用数据类型

使用`interface`关键字定义

```java
public interface 接口名称 {
  // 抽象方法（供子类实现使用）
  // 默认方法（供子类调用或供子类重写）
  // 静态方法（接口可以直接调用）
  // 私有方法
}
```





### 接口与类的关系

接口与类的关系为实现关系，即**类实现接口**

该类可以称为接口的实现类，也可以称为接口的子类

```java
class 类名 implements 接口名() {
  // 重写接口中的抽象方法
  // 重写接口中的默认方法
}
```







#### 接口使用步骤

##### 1.接口不能直接使用，必须有一个<实现类>实现该接口

##### 2.接口中的实现类必须覆盖重写接口中的所有实现方法

##### 3.创建实现类的对象，进行使用

如果实现类并没有覆盖实现接口中的所有抽象方法，那么这个实现类自己就必须是抽象类。



#### 默认方法

与抽象方法对比

可以有方法体

##### 作用

解决接口升级的问题，没有完全重写所有抽象方法，但已经投入使用

##### 默认方法会被实现类继承



#### 注意

1. 接口的默认方法，可以通过接口实现类的类对象直接调用

2. 接口的默认方法，也可以被接口实现类进行覆盖重写



#### 静态方法

接口当中允许定义静态方法

没有抽象方法，所以没有必要在实现类来覆盖重写静态方法



##### 注意

不能通过接口实现类的对象来调用接口当中的静态方法



##### 调用格式

```java
接口名称.静态方法名(参数);
```



#### 私有方法

私有方法是对默认方法和静态方法的辅助



- **私有方法**

  解决多个默认方法的代码重复问题

```java
private 返回值类型 方法名称(参数列表) {
  	方法体;
}
```



- **私有静态方法**

  解决多个静态方法之间的重复代码问题

```java
private static 返回值类型 方法名称(参数列表) {
  方法体;
}
```





##### 解决的问题：

抽取一个公共方法，用来解决方法之间的代码重发问题

**这个公共方法不应让实现类使用，用该私有化**



#### 接口中定义成员变量



##### 格式

```java
public static final 数据类型 常量名称 = 数据值;
```



##### 注意事项

1. 一旦使用`final`关键字进行修饰，说明不可改变

2. 接口中的常量必须进行赋值，不能不赋值

3. 接口中常量的字母，使用完全大写，用下划线进行分隔







---

### 接口小结

1. 接口中最重要的就是抽象方法，格式

```java
[public] [abstract] 返回值类型 方法名称(参数列表);
```

实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类



2. Java8开始，接口允许定义默认方法

```java
[public] default 返回值类型 方法名称(参数列表) {
  方法体
}
```

默认方法也可以被覆盖重写



3. Java8开始，接口允许定义静态方法

```java
[public] static 返回值类型 方法名称(参数列表){
  方法体
}
```

应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法



4. java9开始，接口里允许定义私有方法

```java
private 返回值类型 方法名称(参数列表) {
  	方法体;
}

private static 返回值类型 方法名称(参数列表) {
  方法体;
}
```

私有方法只有接口自己才能调用，不能被实现类或别人使用



---

### 接口使用的注意事项

1. 接口是没有静态代码块或者构造方法的。

2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
  格式：

  ```java
  public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {
   // 覆盖重写所有抽象方法
  }
  ```

3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。

4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。

5. 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。

6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。



---

### 接口之间的多继承

类与类之间是单继承的，直接父类只有一个。

类与接口之间是多实现的，一个类可以实现多个接口。

接口与接口之间是多继承的。





---

### 多态

`extends`继承和`implements`实现，是多态性的前提

同一行为，通过不同的事物，可以体现出来不同的形态。多态，就是描述这样的状态。



**多态指的是对象，不是类。**



#### 代码当中体现多态性

**父类引用指向子类对象**

```java
父类名称 对象名 = new 子类名称();
```

或者

```java
接口名称 对象名 = new 实现类名称();
```



#### 成员变量在多态中的规则

编译看左边，运行看左边

#### 成员方法在多态中的规则

编译看左边，运行看右边



---



#### 使用多态的好处

编写程序更简单。并且有良好的扩展



---

#### 多态的转型

##### 向上转型

多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。

向上转型一定是安全的

**子类一旦转型为父类，就无法调用子类原本特有的内容**





##### 向下转型 

其实就是一个还原的动作

将父类对象，还原成为**本来的子类对象**

格式：

```java
子类对象 对象名 = (子类名称) 父类对象;
```



#### `instanceof`关键字

```java
变量名 instanceof 数据类型 
```



如果变量属于该数据类型，返回true。 

如果变量不属于该数据类型，返回false。



