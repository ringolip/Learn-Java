### 多线程



#### Lock锁

JDK5之后针对线程的锁定操作和释放操作

---



#### 死锁问题的描述和代码体现

是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象



##### 同步弊端

效率低

如果出现了同步嵌套，就容易产生死锁问题





---



#### 线程间通信（生产者消费者问题）

多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。 

#### 等待唤醒机制

就是在一个线程进行了规定操作后，就进入等待状态（**wait()**）， 等待其他线程执行完他们的指定代码过后 再将 

其唤醒（**notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 

wait/notify 就是线程间的一种协作机制。





**等待唤醒中的方法** 

等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下： 

\1. wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时 

的线程状态即是 WAITING。它还要等着别的线程执行一个**特别的动作**，也即是“**通知（****notify****）**”在这个对象 

上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 

\2. notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先 

入座。 

\3. notifyAll：则释放所通知对象的 wait set 上的全部线程。



---



#### 线程组

Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控

制。

默认情况下，所有的线程都属于主线程组。

public final ThreadGroup getThreadGroup()

我们也可以给线程设置分组

Thread(ThreadGroup group, Runnable target, String name) 



---



#### 线程池



##### 很好地提高性能

程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性

能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。



线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。



从JDK5开始，Java内置支持线程池







#### 匿名内部类方式使用多线程



```java
new Thread(){
  代码…
}.start();

```



```java
New Thread(new Runnable(){
  代码…}).start();

```





---

#### 定时器



定时器是一个应用十分广泛的线程工具，**可用于调度多个定时任务以后台线程的方式执行**。

在Java中，可以通过Timer和TimerTask类来实现定义调度的功能



##### Timer

- public Timer()
- public void schedule(TimerTask task, long delay)
- public void schedule(TimerTask task,long delay,long period)

##### TimerTask

- public abstract void run()
- public boolean cancel()





























---



### 设计模式



### 面向对象的常见设计原则

在实际的开发中，我们要想更深入的了解面向对象思想，就必须熟悉前人总结过的面向对象的思想的设计原则



#### 单一

每个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。在设计模式中，所有的设计模式都遵循这一原则



#### 开闭

对类的改动是通过增加代码进行的，而不是修改现有代码。



​		

#### 里氏

同一个继承体系中的对象应该有共同的行为特征。



#### 依赖注入

在应用程序中，所有的类如果使用或依赖于其他的类，则应该依赖这些其他类的抽象类，而不是这些其他类的具体类。



#### 接口

不应该强迫程序依赖它们不需要使用的方法。

一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。



#### 迪米特

一个对象应当对其他对象尽可能少的了解

其实就是说：降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块

的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用



都是为了高内聚，低耦合



---



#### 设计模式概述和分类

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。



模式分为三类：

创建型模式 对象的创建

结构型模式 对象的组成(结构)

行为型模式 对象的行为



简单工厂模式
		B:工厂方法模式
		C:单例模式(掌握)



---

### 计算机网络

网络模型一般是指

- OSI（Open System Interconnection开放系统互连）参考模型
- TCP/IP参考模型



网络模型7层概述：

1. 物理层：**主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等**。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 

2. 数据链路层：**主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装**。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 

3. 网络层：**主要将从下层接收到的数据进行IP地址（例192.168.0.1)的封装与解封装**。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 

4. 传输层：**定义了一些传输数据的协议和端口号**（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 

5. 会话层：通过传输层（端口号：传输端口与接收端口）**建立数据传输的通路**。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） 

6. 表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（**也就是把计算机能够识别的东西转换成人能够能识别的东西**（如图片、声音等）。 

6. 应用层： 主要是一些**终端的应用**，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。





#### 网络通信三要素



##### IP地址

##### 端口号

##### 传输协议

UDP
		将数据源和目的封装成数据包中，不需要建立连接；**每个数据报的大小在限制在64k**；因无连接，是不可靠协

议；不需要建立连接，速度快

TCP
		建立连接，形成传输数据的通道；在连接中进行大数据量传输；通过三次握手完成连接，是可靠协议；必须

建立连接，效率会稍低

##### 

#### Socket套接字

IP+端口

网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。

Socket原理机制：

通信的两端都有Socket。

网络通信其实就是Socket间的通信。

数据在两个Socket间通过IO传输。





